#!/usr/bin/env python

__doc__ = """
Run RIP residue perturbation MD simulations for a 
PDB structure. Note residues are counted from 0, 
which is Python-style counting

Usage: ripit high <pdb> <out_dir>
       ripit low <pdb> <out_dir>
       ripit run <param> ...
       ripit couple <pdb> <rip_dir>
       ripit flex <pdb> <rip_dir>

Example: Generate the config files for a set of MD
runs for a high temperature RIP run.

    >>> ripit high example.pdb high_rip

Example: Generate the config files for a set of MD
runs for a high temperature RIP run.

    >>> ripit low example.pdb low_rip

"""

import os
import time
import math

import numpy as np
from matplotlib import pylab

from jinja2 import Template

from pdbremix import pdbatoms
from pdbremix import simulate
from pdbremix.lib.docopt import docopt
from pdbremix import force
from pdbremix import util
from pdbremix import pdbtext
from pdbremix import trajectory
from pdbremix import fetch
from pdbremix import data
from pdbremix import v3
from pdbremix import trajectory
from pdbremix import pymol



def make_restraint_pdb(
    in_md, residue_indices, out_pdb, is_backbone_only=True):
  soup = simulate.soup_from_restart_files(in_md)
  for i_res in residue_indices:
    for a in soup.residue(i_res).atoms():
      if is_backbone_only and a.type not in data.backbone_atoms:
        continue
      a.bfactor = 1.0
  soup.write_pdb(out_pdb)


def run_equil(params):
  pdb = params['pdb']
  clean_pdb = os.path.split(pdb)[-1] + '.clean.pdb'
  print os.getcwd(), clean_pdb
  pdbtext.clean_pdb(pdb, clean_pdb)

  print "> Generating topologies"
  top, crds = simulate.pdb_to_top_and_crds(
      params['ff'], clean_pdb, 'sim')

  util.goto_dir('equil')

  temperature = params['equil_temperature']

  simulate.minimize(params['ff'], '../sim', 'min')

  print "> Heating to %dK" % temperature
  simulate.langevin_thermometer(
      params['ff'], 'min', 1000, temperature, 'heat', 50)

  print "> Constant energy relaxation"
  simulate.constant_energy(
      params['ff'], 'heat', 1000, 'const', 50)

  print "> Reheat to %dK" % temperature
  simulate.langevin_thermometer(
      params['ff'], 'const', 1000, temperature, 'reheat', 50)

  print "> Merge into single equil trajecotry"
  simulate.merge_trajectories(
      params['ff'], 'equil', ['heat', 'const', 'reheat'])

  util.write_dict('equil.config', params)

  util.goto_dir('..')


def run_or_wait_for_equil(params):
  sim_dir = params['sim_dir']
  util.goto_dir(sim_dir)
  print sim_dir
  if os.path.isdir('equil'):
    while not os.path.isfile('equil/equil.config'):
      time.sleep(1)
      print "Waiting for equil to finish..."
    return
  run_equil(params)


def run_puff(params):
  util.goto_dir(params['sim_dir'])

  i_residue = params['i_residue']
  res_dir = '%s/%d' % (params['var_name'], i_residue)
  restraint_pdb = ''
  in_md = os.path.abspath('equil/equil')

  print "> Pulse with RIP on residue %d" % i_residue

  util.goto_dir(res_dir)
  simulate.pulse(
      params['ff'], 
      in_md,  
      'md', 
      params['n_step'],
      force.make_rip_fn(
          params['i_residue'],
          params['rip_temperature']), 
      100,
      restraint_pdb=restraint_pdb)


def process_config(config):
  done = config + '.done'
  save_dir = os.getcwd()
  if not os.path.isfile(done):
    params = util.read_dict(config)
    run_or_wait_for_equil(params)
    run_puff(params)
    os.chdir(save_dir)
    open(done, 'w').write('done')


def prepare_high(pdb, sim_dir):
  if not sim_dir:
    sim_dir = os.getcwd()
  sim_dir = os.path.abspath(sim_dir)
  pdb = os.path.abspath(pdb)
  soup = pdbatoms.Soup(pdb)
  pdb_code = os.path.splitext(pdb)[0]
  var_name = 'rip'
  for i_res, res in enumerate(soup.residues()):
    if res.type not in data.solvent_res_types:
      if force.get_n_chi(res) and res.type != 'PRO':
        config = '%s.%s.res%d.config' % (pdb_code, var_name, i_res)
        print res.tag(), res.type, '->', util.relpath(config)
        params = {
          'ff': 'AMBER11-GBSA',
          'pdb': pdb,
          'i_residue': i_res,
          'rip_temperature': 300,
          'equil_temperature': 300,
          'n_step': 5000, 
          'var_name': var_name,
          'sim_dir': sim_dir,
        }
        util.write_dict(config, params)


def prepare_low(pdb, sim_dir):
  if not sim_dir:
    sim_dir = os.getcwd()
  sim_dir = os.path.abspath(sim_dir)
  pdb = os.path.abspath(pdb)
  soup = pdbatoms.Soup(pdb)
  pdb_code = os.path.splitext(pdb)[0]
  var_name = 'rip'
  for i_res, res in enumerate(soup.residues()):
    if res.type not in data.solvent_res_types:
      if force.get_n_chi(res) and res.type != 'PRO':
        config = '%s.%s.res%d.config' % (pdb_code, var_name, i_res)
        print res.tag(), res.type, '->', util.relpath(config)
        params = {
          'ff': 'AMBER11-GBSA',
          'pdb': pdb,
          'i_residue': i_res,
          'rip_temperature': 26,
          'equil_temperature': 10,
          'n_step': 5000, 
          'var_name': var_name,
          'sim_dir': sim_dir,
        }
        util.write_dict(config, params)


############################################
# flexibility RIP-analysis 

def get_res_dir_list(rip_dir):
  for root_dir, dirnames, fnames in os.walk(rip_dir):
    if root_dir == rip_dir:
      res_dir_list = [d for d in dirnames if d.isdigit()]
      break
  res_dir_list.sort(key=lambda r: int(r))
  return res_dir_list


def get_matrix_from_dir(
    n_res, rip_dir, md_var_fname='md.dev.per_frame'):
  matrix = np.zeros((n_res, n_res))
  for res_dir in get_res_dir_list(rip_dir):
    i_res = int(res_dir)
    fname = os.path.join(rip_dir, res_dir, md_var_fname)
    if not os.path.isfile(fname):
      md = os.path.join(rip_dir, res_dir, 'md')
      trajectory.analyze_trajectory(md)
    last_line = open(fname).readlines()[-1]
    words = last_line.split()
    matrix[i_res][:] = map(float, words[1:])
  return matrix


def make_block_matrix(matrix, min_val):
  """
  Uses a min_val cutoff and converts a float-based matrix
  array into a binary 1,0 array.
  """
  result = matrix.copy()
  n_x, n_y = np.shape(matrix)
  for i in range(n_x):
    for j in range(n_y):
      if result[i,j] > min_val:
        result[i,j] = 1
      else:
        result[i,j] = 0
  return result


def count_vals_over_min_per_column(matrix, min_val):
  block_matrix = make_block_matrix(matrix, min_val)
  n_bin = block_matrix.shape[0]
  for i in range(n_bin):
    block_matrix[i,i] = 0
  result = np.zeros(n_bin, int)
  for i in range(n_bin):
    result[i] = sum(block_matrix[i,:])
  return result


def write_matrix(matrix, fname):
  n_bin = matrix.shape[0]
  lines = []
  for j in range(n_bin):
    strs = [str(val) for val in matrix[:,j]]
    line = ' '.join(strs)
    lines.append(line)
  open(fname, 'w').write('\n'.join(lines))


def write_vals(vals, fname):
  line = ' '.join(map(str, vals))
  open(fname, 'w').write(line)


def write_soup_bfactor(soup, bfactors, pdb):
  for a in soup.atoms():
    a.bfactor = 0.0
  residues = [r for r in soup.residues() if r.has_atom('CA')]
  for bfactor, res in zip(bfactors, residues):
    for a in res.atoms():
      a.bfactor = bfactor
  soup.write_pdb(pdb)


def write_matrix_png(matrix, png, max_val=None):
  pylab.clf()
  
  # make room for legend
  pylab.axes([.1, .1, .7, .8])

  # draw heat map
  plot = pylab.imshow(matrix, interpolation='none', vmax=max_val)
  plot.set_cmap('Reds')
  pylab.colorbar()

  # draw diagonal lines of green circles
  x_vals, y_vals = [], []
  n = matrix.shape[0]
  size = int((350/float(n))**2)
  if size==0:
    size = 1
  for i in range(n):
    if sum(matrix[i,:]) > 0:
      x_vals.append(i)
      y_vals.append(i)
  if x_vals:
    pylab.scatter(
        x_vals, y_vals, s=size, marker='o', 
        facecolor='g', edgecolor='none') 
  pylab.xlim([-0.5, n-0.5])
  pylab.ylim([-0.5, n-0.5])

  pylab.savefig(png)


def get_fluctuations_per_column(matrix, min_val):
  n_residue = matrix.shape[0]
  y_vals = []
  for j in range(n_residue):
    fluctuations = []
    for i in range(n_residue):
      v = matrix[i,j]
      if abs(i-j) > 3 and v > min_val:
        fluctuations.append(v-min_val)
    if fluctuations:
      mean = sum(fluctuations)/float(len(fluctuations))
    else:
      mean = 0.0
    y_vals.append(mean)
  return y_vals


def analyze_flex_rip_dir(pdb, rip_dir):
  min_val, max_val = 6, 10
  out_dir = os.path.join(rip_dir, '..', 'summary')
  if not os.path.isdir(out_dir):
    os.makedirs(out_dir)

  soup = pdbatoms.Soup(pdb)
  has_ca = lambda r: r.has_atom('CA')
  n_res = len(filter(has_ca, soup.residues()))

  matrix = get_matrix_from_dir(n_res, rip_dir, 'md.dev.per_frame')

  max_rmsd = 10
  write_matrix(matrix, os.path.join(out_dir, 'map.txt'))
  write_matrix_png(matrix, os.path.join(out_dir, 'map.png'), max_rmsd)
  
  vals = count_vals_over_min_per_column(matrix, min_val)
  write_soup_bfactor(
      soup, vals, os.path.join(out_dir, 'strength.pdb'))
  write_vals(vals, os.path.join(out_dir, 'strength.txt'))

  vals = count_vals_over_min_per_column(matrix.transpose(), min_val)
  write_soup_bfactor(
      soup, vals, os.path.join(out_dir, 'flexibility.pdb'))
  write_vals(vals, os.path.join(out_dir, 'flexibility.txt'))

  vals = get_fluctuations_per_column(matrix, min_val)
  write_soup_bfactor(
      soup, vals, os.path.join(out_dir, 'fluctuation.pdb'))
  write_vals(vals, os.path.join(out_dir, 'fluctuations.txt'))


###################################################
# COUPLING analysis routines

def is_connected(i, j, soup, cutoff=3.5):
  if i == j:
    return False
  min_dist = 1000.0
  for atom_i in soup.residue(i).atoms():
    for atom_j in soup.residue(j).atoms():
      dist = v3.distance(atom_i.pos, atom_j.pos)
      if dist < min_dist:
        min_dist = dist
  return min_dist < cutoff


backbone = ['CA', 'HA', 'N', 'H', 'O', 'C']
def is_sidechain_connected(i, j, soup, cutoff=3.5):
  if abs(i-j) <= 2:
    return False
  min_dist = 1000.0
  sidechain_atoms_i = [a for a in soup.residue(i).atoms() 
                       if a.type not in backbone]
  for atom_i in sidechain_atoms_i:
    for atom_j in soup.residue(j).atoms():
      dist = v3.distance(atom_i.pos, atom_j.pos)
      if dist < min_dist:
        min_dist = dist
  return min_dist < cutoff


def merge_residues(residues1, residues2):
  for i in residues2:
    if i not in residues1:
      residues1.append(i)
  
  
def get_connected_residues(i, residues, soup):
  connected_residues = [i]
  neighbors = [j for j in residues if is_connected(i, j, soup)]
  connected_residues.extend(neighbors)
  non_neighbors = [j for j in residues if j not in neighbors]
  if non_neighbors:
    for j in neighbors:
      connected_to_j = \
          get_connected_residues(j, non_neighbors, soup)
      merge_residues(connected_residues, connected_to_j)
  return connected_residues


def indices_above_threshold(matrix, i, min_val):
  n = matrix.shape[0]
  return [j for j in range(n) if matrix[i,j] >= min_val and i != j]


def neighbors_above_threshold(i, matrix, min_val, soup):
  residues = indices_above_threshold(matrix, i, min_val)
  return [j for j in residues if is_sidechain_connected(i, j, soup)]

  
def filter_disconnected_residues(i, matrix, min_val, soup):
  n_res = matrix.shape[0]
  residues = indices_above_threshold(matrix, i, min_val)
  neighbors = [j for j in residues 
               if is_sidechain_connected(i, j, soup)]
  non_neighbors = [j for j in residues if j not in neighbors]
  connected_residues = [i]
  for j in neighbors:
    connected_to_j = \
        get_connected_residues(j, non_neighbors, soup)
    merge_residues(connected_residues, connected_to_j)
  for j in range(n_res):
    if j not in connected_residues:
      matrix[i, j] = 0.0    


def filter_indirectly_coupled(i, matrix, min_val, soup):
  n_res = matrix.shape[0]
  residues = indices_above_threshold(matrix, i, min_val)
  neighbors = [j for j in residues 
               if is_sidechain_connected(i, j, soup)]
  for j in range(n_res):
    if j not in neighbors:
      matrix[i, j] = 0.0    


def filter_short_pathways(i, matrix, min_val):
  n_res = matrix.shape[0]
  n_above_min_val = sum([1 for v in matrix[i,:] if v >= min_val])
  if n_above_min_val < 3:
    for j in range(n_res):
      matrix[i, j] = 0.0


def filter_immediate_neighbors(i, matrix, min_val):
  n_res = matrix.shape[0]
  test_j = [j for j in range(i-1, i+1+1) 
            if j>=0 and j<n_res and i!=j]
  for j in test_j:
    matrix[i,j] = 0.0


def make_pathway_from_heatflow(heatflow, min_val, pdb):
  soup = pdbatoms.Soup(pdb)
  pathway = heatflow.copy()
  n_res = pathway.shape[0]
  for i in range(n_res):
    for j in range(n_res):
      if pathway[i,j] <= min_val:
        pathway[i,j] = 0.0
    filter_immediate_neighbors(i, pathway, min_val)
    filter_disconnected_residues(
        i, pathway, min_val, soup)
    filter_short_pathways(i, pathway, min_val)
  return pathway


def make_coupling_from_pathway(pathway, min_val, pdb):
  n_res = pathway.shape[0]
  coupling = np.zeros((n_res, n_res), float)
  soup = pdbatoms.Soup(pdb)
  for i in range(n_res):
    for j in neighbors_above_threshold(
        i, pathway, min_val, soup):
      coupling[i,j] = 1.0
  return coupling


def get_cutoff_from_matrix(matrix):
  vals = [d for d in matrix.flatten() if d > 0.0]
  n = float(len(vals))
  avg = sum(vals)/n
  var = sum((v-avg)**2 for v in vals)/n
  std = math.sqrt(var)
  return avg + 2.0*std


def plot_heat_png(png, x_vals, y_vals, y_min, y_max, i_res):
  pylab.clf()
  pylab.plot(x_vals, y_vals)
  pylab.plot(x_vals, [y_min for x in x_vals], color="red")
  y_rip = y_vals[i_res]
  y_arrow = y_max*0.9
  y_text = y_max*0.92
  y_diff = y_arrow - y_rip - y_max*0.02
  pylab.arrow(
      i_res, y_arrow, 0, -y_diff, 
      edgecolor="green", facecolor="green",
      head_width=0.1, head_length=y_max*0.02)
  pylab.text(
      i_res, y_text, "RIP", color="green",
      horizontalalignment='center')
  pylab.xlim([0, x_vals[-1]])
  pylab.ylim([0, y_max])
  pylab.savefig(png)


def write_coupling_pdb(soup, i_res, j_res, coupling_pdb):
  bfactors = [0 for i in range(len(soup.residues()))]
  bfactors[i_res] = 2.0
  bfactors[j_res] = 1.0
  write_soup_bfactor(soup, bfactors, coupling_pdb)


template = """
<html>
<head><title>{{attributes['name']}}</title></head>
<body>

  <div style="font-size:2em; padding:2em; text-align:left">
    {{attributes['name']}}
  </div>

  {% for entry in attributes['residues']: %}
  <table style="width:100%; border-top:1px solid #CCC">
    <td style="width:260px; vertical-align:top;">
      <span style="font-size:1.5em;">res {{entry['i_res']}}</span>
      <br />
      <img style="height:150px" src="{{entry['plot_png']}}">
    </td>
  </table>
  {% endfor %}

</body></html>
"""


def analyze_couplings_rip_dir(pdb, rip_dir):
  out_dir = os.path.join(rip_dir, '../summary')
  if not os.path.isdir(out_dir):
    os.makedirs(out_dir)

  has_ca = lambda r: r.has_atom('CA')
  n_res = len(filter(has_ca, pdbatoms.Soup(pdb).residues()))

  heatflow = get_matrix_from_dir(
      n_res, rip_dir, 'md.kin.per_frame')
  write_matrix_png(
      heatflow, os.path.join(out_dir, 'heatflow.png'))
  write_matrix(heatflow, os.path.join(out_dir, 'heatflow.txt'))

  min_val = get_cutoff_from_matrix(heatflow)
  max_val = min_val*2.0

  pathway = make_pathway_from_heatflow(heatflow, min_val, pdb)
  write_matrix_png(
      pathway, os.path.join(out_dir, 'pathway.png'))
  write_matrix(pathway, os.path.join(out_dir, 'heatflow.txt'))

  coupling = make_coupling_from_pathway(pathway, min_val, pdb)
  write_matrix_png(
      coupling, os.path.join(out_dir, 'coupling.png'))
  write_matrix(coupling, os.path.join(out_dir, 'coupling.txt'))

  attributes = { 'name': 'Heat Flow', 'residues': [] }
  for res_dir in get_res_dir_list(rip_dir):
    i_res = int(res_dir)
    png = 'heat.res%d.png' % i_res
    plot_heat_png(
      os.path.join(out_dir, png), range(n_res), heatflow[i_res], 
      min_val, 0.2, i_res)
    attributes['residues'].append({ 'i_res': i_res, 'plot_png': png })
  html = Template(template).render(attributes=attributes)
  open(os.path.join(out_dir, 'index.html'), 'w').write(html)

  soup = pdbatoms.Soup(pdb)
  for res_dir in get_res_dir_list(rip_dir):
    i_res = int(res_dir)
    for j_res in range(n_res):
      if coupling[i_res,j_res] > 0:
        coupling_pdb = os.path.join(
            out_dir, 'coupling.res%d.res%d.pdb' % (i_res, j_res))
        write_coupling_pdb(soup, i_res, j_res, coupling_pdb)


if __name__ == "__main__":
  args = docopt(__doc__)
  if args['high']:
    prepare_high(args['<pdb>'], args['<out_dir>'])
  elif args['low']:
    prepare_low(args['<pdb>'], args['<out_dir>'])
  elif args['run']:
    for param in args['<param>']:
      process_config(param)
  elif args['flex']:
    analyze_flex_rip_dir(args['<pdb>'], args['<rip_dir>'])
  elif args['couple']:
    analyze_couplings_rip_dir(args['<pdb>'], args['<rip_dir>'])


